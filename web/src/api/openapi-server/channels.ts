/**
 * Generated by orval v7.2.0 ðŸº
 * Do not edit manually.
 * storyden
 * Storyden social API for building community driven platforms.
The Storyden API does not adhere to semantic versioning but instead applies a rolling strategy with deprecations and minimal breaking changes. This has been done mainly for a simpler development process and it may be changed to a more fixed versioning strategy in the future. Ultimately, the primary way Storyden tracks versions is dates, there are no set release tags currently.

 * OpenAPI spec version: v1.25.13-canary
 */
import type {
  CategoryCreateBody,
  CategoryCreateOKResponse,
  CategoryDeleteBody,
  CategoryDeleteOKResponse,
  CategoryGetOKResponse,
  CategoryListOKResponse,
  CategoryUpdateBody,
  CategoryUpdateOKResponse,
  CategoryUpdatePositionBody,
  ChannelCollectionListParams,
  ChannelGetOKResponse,
  ChannelInitialProps,
  ChannelListOKResponse,
  ChannelMemberAdd,
  ChannelMemberListOKResponse,
  ChannelMemberOKResponse,
  ChannelMemberRoleUpdate,
  ChannelMutableProps,
  ChannelThreadGetParams,
  ChannelThreadListParams,
  CollectionCreateBody,
  CollectionCreateOKResponse,
  CollectionGetOKResponse,
  CollectionListOKResponse,
  CollectionUpdateBody,
  CollectionUpdateOKResponse,
  ReplyCreateBody,
  ReplyCreateOKResponse,
  ThreadCreateBody,
  ThreadCreateOKResponse,
  ThreadGetResponse,
  ThreadListOKResponse,
  ThreadUpdateBody,
  ThreadUpdateOKResponse,
} from "../openapi-schema";
import { fetcher } from "../server";

/**
 * Get all channels that the authenticated user has access to.
 */
export type channelListResponse = {
  data: ChannelListOKResponse;
  status: number;
};

export const getChannelListUrl = () => {
  return `/channels`;
};

export const channelList = async (
  options?: RequestInit,
): Promise<channelListResponse> => {
  return fetcher<Promise<channelListResponse>>(getChannelListUrl(), {
    ...options,
    method: "GET",
  });
};

/**
 * Create a new channel. The creator automatically becomes the channel owner.
 */
export type channelCreateResponse = {
  data: ChannelGetOKResponse;
  status: number;
};

export const getChannelCreateUrl = () => {
  return `/channels`;
};

export const channelCreate = async (
  channelInitialProps: ChannelInitialProps,
  options?: RequestInit,
): Promise<channelCreateResponse> => {
  return fetcher<Promise<channelCreateResponse>>(getChannelCreateUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(channelInitialProps),
  });
};

/**
 * Get a specific channel by ID.
 */
export type channelGetResponse = {
  data: ChannelGetOKResponse;
  status: number;
};

export const getChannelGetUrl = (channelID: string) => {
  return `/channels/${channelID}`;
};

export const channelGet = async (
  channelID: string,
  options?: RequestInit,
): Promise<channelGetResponse> => {
  return fetcher<Promise<channelGetResponse>>(getChannelGetUrl(channelID), {
    ...options,
    method: "GET",
  });
};

/**
 * Update a channel's properties. Requires owner or admin role.
 */
export type channelUpdateResponse = {
  data: ChannelGetOKResponse;
  status: number;
};

export const getChannelUpdateUrl = (channelID: string) => {
  return `/channels/${channelID}`;
};

export const channelUpdate = async (
  channelID: string,
  channelMutableProps: ChannelMutableProps,
  options?: RequestInit,
): Promise<channelUpdateResponse> => {
  return fetcher<Promise<channelUpdateResponse>>(
    getChannelUpdateUrl(channelID),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(channelMutableProps),
    },
  );
};

/**
 * Delete a channel. Requires owner role. This will also delete all associated content.
 */
export type channelDeleteResponse = {
  data: void;
  status: number;
};

export const getChannelDeleteUrl = (channelID: string) => {
  return `/channels/${channelID}`;
};

export const channelDelete = async (
  channelID: string,
  options?: RequestInit,
): Promise<channelDeleteResponse> => {
  return fetcher<Promise<channelDeleteResponse>>(
    getChannelDeleteUrl(channelID),
    {
      ...options,
      method: "DELETE",
    },
  );
};

/**
 * List all members of a channel. Requires membership in the channel.
 */
export type channelMemberListResponse = {
  data: ChannelMemberListOKResponse;
  status: number;
};

export const getChannelMemberListUrl = (channelID: string) => {
  return `/channels/${channelID}/members`;
};

export const channelMemberList = async (
  channelID: string,
  options?: RequestInit,
): Promise<channelMemberListResponse> => {
  return fetcher<Promise<channelMemberListResponse>>(
    getChannelMemberListUrl(channelID),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Add a member to a channel. Requires owner or admin role.
 */
export type channelMemberAddResponse = {
  data: ChannelMemberOKResponse;
  status: number;
};

export const getChannelMemberAddUrl = (channelID: string) => {
  return `/channels/${channelID}/members`;
};

export const channelMemberAdd = async (
  channelID: string,
  channelMemberAdd: ChannelMemberAdd,
  options?: RequestInit,
): Promise<channelMemberAddResponse> => {
  return fetcher<Promise<channelMemberAddResponse>>(
    getChannelMemberAddUrl(channelID),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(channelMemberAdd),
    },
  );
};

/**
 * Update a member's role in a channel. Requires owner or admin role.
 */
export type channelMemberUpdateRoleResponse = {
  data: ChannelMemberOKResponse;
  status: number;
};

export const getChannelMemberUpdateRoleUrl = (
  channelID: string,
  accountID: string,
) => {
  return `/channels/${channelID}/members/${accountID}`;
};

export const channelMemberUpdateRole = async (
  channelID: string,
  accountID: string,
  channelMemberRoleUpdate: ChannelMemberRoleUpdate,
  options?: RequestInit,
): Promise<channelMemberUpdateRoleResponse> => {
  return fetcher<Promise<channelMemberUpdateRoleResponse>>(
    getChannelMemberUpdateRoleUrl(channelID, accountID),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(channelMemberRoleUpdate),
    },
  );
};

/**
 * Remove a member from a channel. Requires owner or admin role.
 */
export type channelMemberRemoveResponse = {
  data: void;
  status: number;
};

export const getChannelMemberRemoveUrl = (
  channelID: string,
  accountID: string,
) => {
  return `/channels/${channelID}/members/${accountID}`;
};

export const channelMemberRemove = async (
  channelID: string,
  accountID: string,
  options?: RequestInit,
): Promise<channelMemberRemoveResponse> => {
  return fetcher<Promise<channelMemberRemoveResponse>>(
    getChannelMemberRemoveUrl(channelID, accountID),
    {
      ...options,
      method: "DELETE",
    },
  );
};

/**
 * Join a public channel as a member. Only works for public channels.
 */
export type channelJoinResponse = {
  data: ChannelMemberOKResponse;
  status: number;
};

export const getChannelJoinUrl = (channelID: string) => {
  return `/channels/${channelID}/join`;
};

export const channelJoin = async (
  channelID: string,
  options?: RequestInit,
): Promise<channelJoinResponse> => {
  return fetcher<Promise<channelJoinResponse>>(getChannelJoinUrl(channelID), {
    ...options,
    method: "POST",
  });
};

/**
 * Leave a channel. Cannot leave if you are the only owner.
 */
export type channelLeaveResponse = {
  data: void;
  status: number;
};

export const getChannelLeaveUrl = (channelID: string) => {
  return `/channels/${channelID}/leave`;
};

export const channelLeave = async (
  channelID: string,
  options?: RequestInit,
): Promise<channelLeaveResponse> => {
  return fetcher<Promise<channelLeaveResponse>>(getChannelLeaveUrl(channelID), {
    ...options,
    method: "POST",
  });
};

/**
 * Get all categories in a channel.
 */
export type channelCategoryListResponse = {
  data: CategoryListOKResponse;
  status: number;
};

export const getChannelCategoryListUrl = (channelID: string) => {
  return `/channels/${channelID}/categories`;
};

export const channelCategoryList = async (
  channelID: string,
  options?: RequestInit,
): Promise<channelCategoryListResponse> => {
  return fetcher<Promise<channelCategoryListResponse>>(
    getChannelCategoryListUrl(channelID),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Create a category in a channel.
 */
export type channelCategoryCreateResponse = {
  data: CategoryCreateOKResponse;
  status: number;
};

export const getChannelCategoryCreateUrl = (channelID: string) => {
  return `/channels/${channelID}/categories`;
};

export const channelCategoryCreate = async (
  channelID: string,
  categoryCreateBody: CategoryCreateBody,
  options?: RequestInit,
): Promise<channelCategoryCreateResponse> => {
  return fetcher<Promise<channelCategoryCreateResponse>>(
    getChannelCategoryCreateUrl(channelID),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(categoryCreateBody),
    },
  );
};

/**
 * Get a specific category in a channel.
 */
export type channelCategoryGetResponse = {
  data: CategoryGetOKResponse;
  status: number;
};

export const getChannelCategoryGetUrl = (
  channelID: string,
  categorySlug: string,
) => {
  return `/channels/${channelID}/categories/${categorySlug}`;
};

export const channelCategoryGet = async (
  channelID: string,
  categorySlug: string,
  options?: RequestInit,
): Promise<channelCategoryGetResponse> => {
  return fetcher<Promise<channelCategoryGetResponse>>(
    getChannelCategoryGetUrl(channelID, categorySlug),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Update a category in a channel.
 */
export type channelCategoryUpdateResponse = {
  data: CategoryUpdateOKResponse;
  status: number;
};

export const getChannelCategoryUpdateUrl = (
  channelID: string,
  categorySlug: string,
) => {
  return `/channels/${channelID}/categories/${categorySlug}`;
};

export const channelCategoryUpdate = async (
  channelID: string,
  categorySlug: string,
  categoryUpdateBody: CategoryUpdateBody,
  options?: RequestInit,
): Promise<channelCategoryUpdateResponse> => {
  return fetcher<Promise<channelCategoryUpdateResponse>>(
    getChannelCategoryUpdateUrl(channelID, categorySlug),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(categoryUpdateBody),
    },
  );
};

/**
 * Delete a category. Posts will be moved to target category.
 */
export type channelCategoryDeleteResponse = {
  data: CategoryDeleteOKResponse;
  status: number;
};

export const getChannelCategoryDeleteUrl = (
  channelID: string,
  categorySlug: string,
) => {
  return `/channels/${channelID}/categories/${categorySlug}`;
};

export const channelCategoryDelete = async (
  channelID: string,
  categorySlug: string,
  categoryDeleteBody: CategoryDeleteBody,
  options?: RequestInit,
): Promise<channelCategoryDeleteResponse> => {
  return fetcher<Promise<channelCategoryDeleteResponse>>(
    getChannelCategoryDeleteUrl(channelID, categorySlug),
    {
      ...options,
      method: "DELETE",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(categoryDeleteBody),
    },
  );
};

/**
 * Update category position in the tree for drag-and-drop.
 */
export type channelCategoryUpdatePositionResponse = {
  data: CategoryListOKResponse;
  status: number;
};

export const getChannelCategoryUpdatePositionUrl = (
  channelID: string,
  categorySlug: string,
) => {
  return `/channels/${channelID}/categories/${categorySlug}/position`;
};

export const channelCategoryUpdatePosition = async (
  channelID: string,
  categorySlug: string,
  categoryUpdatePositionBody: CategoryUpdatePositionBody,
  options?: RequestInit,
): Promise<channelCategoryUpdatePositionResponse> => {
  return fetcher<Promise<channelCategoryUpdatePositionResponse>>(
    getChannelCategoryUpdatePositionUrl(channelID, categorySlug),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(categoryUpdatePositionBody),
    },
  );
};

/**
 * Create a new thread within a channel category.
 */
export type channelThreadCreateResponse = {
  data: ThreadCreateOKResponse;
  status: number;
};

export const getChannelThreadCreateUrl = (channelID: string) => {
  return `/channels/${channelID}/threads`;
};

export const channelThreadCreate = async (
  channelID: string,
  threadCreateBody: ThreadCreateBody,
  options?: RequestInit,
): Promise<channelThreadCreateResponse> => {
  return fetcher<Promise<channelThreadCreateResponse>>(
    getChannelThreadCreateUrl(channelID),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(threadCreateBody),
    },
  );
};

/**
 * Get a list of threads in a channel.
 */
export type channelThreadListResponse = {
  data: ThreadListOKResponse;
  status: number;
};

export const getChannelThreadListUrl = (
  channelID: string,
  params?: ChannelThreadListParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["visibility"];

    if (value instanceof Array && explodeParameters.includes(key)) {
      value.forEach((v) =>
        normalizedParams.append(key, v === null ? "null" : v.toString()),
      );
      return;
    }

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  return normalizedParams.size
    ? `/channels/${channelID}/threads?${normalizedParams.toString()}`
    : `/channels/${channelID}/threads`;
};

export const channelThreadList = async (
  channelID: string,
  params?: ChannelThreadListParams,
  options?: RequestInit,
): Promise<channelThreadListResponse> => {
  return fetcher<Promise<channelThreadListResponse>>(
    getChannelThreadListUrl(channelID, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Get information about a thread in a channel including its posts.
 * @summary Get a thread from a channel.
 */
export type channelThreadGetResponse = {
  data: ThreadGetResponse;
  status: number;
};

export const getChannelThreadGetUrl = (
  channelID: string,
  threadMark: string,
  params?: ChannelThreadGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  return normalizedParams.size
    ? `/channels/${channelID}/threads/${threadMark}?${normalizedParams.toString()}`
    : `/channels/${channelID}/threads/${threadMark}`;
};

export const channelThreadGet = async (
  channelID: string,
  threadMark: string,
  params?: ChannelThreadGetParams,
  options?: RequestInit,
): Promise<channelThreadGetResponse> => {
  return fetcher<Promise<channelThreadGetResponse>>(
    getChannelThreadGetUrl(channelID, threadMark, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Update a thread in a channel.
 */
export type channelThreadUpdateResponse = {
  data: ThreadUpdateOKResponse;
  status: number;
};

export const getChannelThreadUpdateUrl = (
  channelID: string,
  threadMark: string,
) => {
  return `/channels/${channelID}/threads/${threadMark}`;
};

export const channelThreadUpdate = async (
  channelID: string,
  threadMark: string,
  threadUpdateBody: ThreadUpdateBody,
  options?: RequestInit,
): Promise<channelThreadUpdateResponse> => {
  return fetcher<Promise<channelThreadUpdateResponse>>(
    getChannelThreadUpdateUrl(channelID, threadMark),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(threadUpdateBody),
    },
  );
};

/**
 * Delete a thread in a channel.
 */
export type channelThreadDeleteResponse = {
  data: void;
  status: number;
};

export const getChannelThreadDeleteUrl = (
  channelID: string,
  threadMark: string,
) => {
  return `/channels/${channelID}/threads/${threadMark}`;
};

export const channelThreadDelete = async (
  channelID: string,
  threadMark: string,
  options?: RequestInit,
): Promise<channelThreadDeleteResponse> => {
  return fetcher<Promise<channelThreadDeleteResponse>>(
    getChannelThreadDeleteUrl(channelID, threadMark),
    {
      ...options,
      method: "DELETE",
    },
  );
};

/**
 * Create a new reply within a thread in a channel.
 */
export type channelReplyCreateResponse = {
  data: ReplyCreateOKResponse;
  status: number;
};

export const getChannelReplyCreateUrl = (
  channelID: string,
  threadMark: string,
) => {
  return `/channels/${channelID}/threads/${threadMark}/replies`;
};

export const channelReplyCreate = async (
  channelID: string,
  threadMark: string,
  replyCreateBody: ReplyCreateBody,
  options?: RequestInit,
): Promise<channelReplyCreateResponse> => {
  return fetcher<Promise<channelReplyCreateResponse>>(
    getChannelReplyCreateUrl(channelID, threadMark),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(replyCreateBody),
    },
  );
};

/**
 * Create a collection within a channel for curating posts.
 */
export type channelCollectionCreateResponse = {
  data: CollectionCreateOKResponse;
  status: number;
};

export const getChannelCollectionCreateUrl = (channelID: string) => {
  return `/channels/${channelID}/collections`;
};

export const channelCollectionCreate = async (
  channelID: string,
  collectionCreateBody: CollectionCreateBody,
  options?: RequestInit,
): Promise<channelCollectionCreateResponse> => {
  return fetcher<Promise<channelCollectionCreateResponse>>(
    getChannelCollectionCreateUrl(channelID),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(collectionCreateBody),
    },
  );
};

/**
 * Get a list of collections within a channel.
 */
export type channelCollectionListResponse = {
  data: CollectionListOKResponse;
  status: number;
};

export const getChannelCollectionListUrl = (
  channelID: string,
  params?: ChannelCollectionListParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  return normalizedParams.size
    ? `/channels/${channelID}/collections?${normalizedParams.toString()}`
    : `/channels/${channelID}/collections`;
};

export const channelCollectionList = async (
  channelID: string,
  params?: ChannelCollectionListParams,
  options?: RequestInit,
): Promise<channelCollectionListResponse> => {
  return fetcher<Promise<channelCollectionListResponse>>(
    getChannelCollectionListUrl(channelID, params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Get a collection by its ID within a channel.
 */
export type channelCollectionGetResponse = {
  data: CollectionGetOKResponse;
  status: number;
};

export const getChannelCollectionGetUrl = (
  channelID: string,
  collectionMark: string,
) => {
  return `/channels/${channelID}/collections/${collectionMark}`;
};

export const channelCollectionGet = async (
  channelID: string,
  collectionMark: string,
  options?: RequestInit,
): Promise<channelCollectionGetResponse> => {
  return fetcher<Promise<channelCollectionGetResponse>>(
    getChannelCollectionGetUrl(channelID, collectionMark),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Update a collection within a channel.
 */
export type channelCollectionUpdateResponse = {
  data: CollectionUpdateOKResponse;
  status: number;
};

export const getChannelCollectionUpdateUrl = (
  channelID: string,
  collectionMark: string,
) => {
  return `/channels/${channelID}/collections/${collectionMark}`;
};

export const channelCollectionUpdate = async (
  channelID: string,
  collectionMark: string,
  collectionUpdateBody: CollectionUpdateBody,
  options?: RequestInit,
): Promise<channelCollectionUpdateResponse> => {
  return fetcher<Promise<channelCollectionUpdateResponse>>(
    getChannelCollectionUpdateUrl(channelID, collectionMark),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(collectionUpdateBody),
    },
  );
};

/**
 * Delete a collection within a channel.
 */
export type channelCollectionDeleteResponse = {
  data: void;
  status: number;
};

export const getChannelCollectionDeleteUrl = (
  channelID: string,
  collectionMark: string,
) => {
  return `/channels/${channelID}/collections/${collectionMark}`;
};

export const channelCollectionDelete = async (
  channelID: string,
  collectionMark: string,
  options?: RequestInit,
): Promise<channelCollectionDeleteResponse> => {
  return fetcher<Promise<channelCollectionDeleteResponse>>(
    getChannelCollectionDeleteUrl(channelID, collectionMark),
    {
      ...options,
      method: "DELETE",
    },
  );
};

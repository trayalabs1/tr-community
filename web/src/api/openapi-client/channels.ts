/**
 * Generated by orval v7.2.0 ðŸº
 * Do not edit manually.
 * storyden
 * Storyden social API for building community driven platforms.
The Storyden API does not adhere to semantic versioning but instead applies a rolling strategy with deprecations and minimal breaking changes. This has been done mainly for a simpler development process and it may be changed to a more fixed versioning strategy in the future. Ultimately, the primary way Storyden tracks versions is dates, there are no set release tags currently.

 * OpenAPI spec version: v1.25.13-canary
 */
import useSwr from "swr";
import type { Arguments, Key, SWRConfiguration } from "swr";
import useSWRMutation from "swr/mutation";
import type { SWRMutationConfiguration } from "swr/mutation";

import { fetcher } from "../client";
import type {
  BadRequestResponse,
  CategoryCreateBody,
  CategoryCreateOKResponse,
  CategoryDeleteBody,
  CategoryDeleteOKResponse,
  CategoryGetOKResponse,
  CategoryListOKResponse,
  CategoryUpdateBody,
  CategoryUpdateOKResponse,
  CategoryUpdatePositionBody,
  ChannelCollectionListParams,
  ChannelGetOKResponse,
  ChannelInitialProps,
  ChannelListOKResponse,
  ChannelMemberAdd,
  ChannelMemberListOKResponse,
  ChannelMemberOKResponse,
  ChannelMemberRoleUpdate,
  ChannelMutableProps,
  ChannelThreadGetParams,
  ChannelThreadListParams,
  CollectionCreateBody,
  CollectionCreateOKResponse,
  CollectionGetOKResponse,
  CollectionListOKResponse,
  CollectionUpdateBody,
  CollectionUpdateOKResponse,
  ForbiddenResponse,
  InternalServerErrorResponse,
  NotFoundResponse,
  NotModifiedResponse,
  ReplyCreateBody,
  ReplyCreateOKResponse,
  ThreadCreateBody,
  ThreadCreateOKResponse,
  ThreadGetResponse,
  ThreadListOKResponse,
  ThreadUpdateBody,
  ThreadUpdateOKResponse,
  UnauthorisedResponse,
} from "../openapi-schema";

/**
 * Get all channels that the authenticated user has access to.
 */
export const channelList = () => {
  return fetcher<ChannelListOKResponse>({ url: `/channels`, method: "GET" });
};

export const getChannelListKey = () => [`/channels`] as const;

export type ChannelListQueryResult = NonNullable<
  Awaited<ReturnType<typeof channelList>>
>;
export type ChannelListQueryError =
  | UnauthorisedResponse
  | InternalServerErrorResponse;

export const useChannelList = <
  TError = UnauthorisedResponse | InternalServerErrorResponse,
>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof channelList>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
}) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getChannelListKey() : null));
  const swrFn = () => channelList();

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Create a new channel. The creator automatically becomes the channel owner.
 */
export const channelCreate = (channelInitialProps: ChannelInitialProps) => {
  return fetcher<ChannelGetOKResponse>({
    url: `/channels`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: channelInitialProps,
  });
};

export const getChannelCreateMutationFetcher = () => {
  return (
    _: Key,
    { arg }: { arg: ChannelInitialProps },
  ): Promise<ChannelGetOKResponse> => {
    return channelCreate(arg);
  };
};
export const getChannelCreateMutationKey = () => [`/channels`] as const;

export type ChannelCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelCreate>>
>;
export type ChannelCreateMutationError =
  | UnauthorisedResponse
  | InternalServerErrorResponse;

export const useChannelCreate = <
  TError = UnauthorisedResponse | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof channelCreate>>,
    TError,
    Key,
    ChannelInitialProps,
    Awaited<ReturnType<typeof channelCreate>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getChannelCreateMutationKey();
  const swrFn = getChannelCreateMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get a specific channel by ID.
 */
export const channelGet = (channelID: string) => {
  return fetcher<ChannelGetOKResponse>({
    url: `/channels/${channelID}`,
    method: "GET",
  });
};

export const getChannelGetKey = (channelID: string) =>
  [`/channels/${channelID}`] as const;

export type ChannelGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof channelGet>>
>;
export type ChannelGetQueryError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelGet = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof channelGet>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!channelID;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getChannelGetKey(channelID) : null));
  const swrFn = () => channelGet(channelID);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Update a channel's properties. Requires owner or admin role.
 */
export const channelUpdate = (
  channelID: string,
  channelMutableProps: ChannelMutableProps,
) => {
  return fetcher<ChannelGetOKResponse>({
    url: `/channels/${channelID}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: channelMutableProps,
  });
};

export const getChannelUpdateMutationFetcher = (channelID: string) => {
  return (
    _: Key,
    { arg }: { arg: ChannelMutableProps },
  ): Promise<ChannelGetOKResponse> => {
    return channelUpdate(channelID, arg);
  };
};
export const getChannelUpdateMutationKey = (channelID: string) =>
  [`/channels/${channelID}`] as const;

export type ChannelUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelUpdate>>
>;
export type ChannelUpdateMutationError =
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelUpdate = <
  TError =
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelUpdate>>,
      TError,
      Key,
      ChannelMutableProps,
      Awaited<ReturnType<typeof channelUpdate>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getChannelUpdateMutationKey(channelID);
  const swrFn = getChannelUpdateMutationFetcher(channelID);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Delete a channel. Requires owner role. This will also delete all associated content.
 */
export const channelDelete = (channelID: string) => {
  return fetcher<void>({ url: `/channels/${channelID}`, method: "DELETE" });
};

export const getChannelDeleteMutationFetcher = (channelID: string) => {
  return (_: Key, __: { arg: Arguments }): Promise<void> => {
    return channelDelete(channelID);
  };
};
export const getChannelDeleteMutationKey = (channelID: string) =>
  [`/channels/${channelID}`] as const;

export type ChannelDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelDelete>>
>;
export type ChannelDeleteMutationError =
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelDelete = <
  TError =
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelDelete>>,
      TError,
      Key,
      Arguments,
      Awaited<ReturnType<typeof channelDelete>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getChannelDeleteMutationKey(channelID);
  const swrFn = getChannelDeleteMutationFetcher(channelID);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * List all members of a channel. Requires membership in the channel.
 */
export const channelMemberList = (channelID: string) => {
  return fetcher<ChannelMemberListOKResponse>({
    url: `/channels/${channelID}/members`,
    method: "GET",
  });
};

export const getChannelMemberListKey = (channelID: string) =>
  [`/channels/${channelID}/members`] as const;

export type ChannelMemberListQueryResult = NonNullable<
  Awaited<ReturnType<typeof channelMemberList>>
>;
export type ChannelMemberListQueryError =
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelMemberList = <
  TError =
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof channelMemberList>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!channelID;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getChannelMemberListKey(channelID) : null));
  const swrFn = () => channelMemberList(channelID);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Add a member to a channel. Requires owner or admin role.
 */
export const channelMemberAdd = (
  channelID: string,
  channelMemberAdd: ChannelMemberAdd,
) => {
  return fetcher<ChannelMemberOKResponse>({
    url: `/channels/${channelID}/members`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: channelMemberAdd,
  });
};

export const getChannelMemberAddMutationFetcher = (channelID: string) => {
  return (
    _: Key,
    { arg }: { arg: ChannelMemberAdd },
  ): Promise<ChannelMemberOKResponse> => {
    return channelMemberAdd(channelID, arg);
  };
};
export const getChannelMemberAddMutationKey = (channelID: string) =>
  [`/channels/${channelID}/members`] as const;

export type ChannelMemberAddMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelMemberAdd>>
>;
export type ChannelMemberAddMutationError =
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelMemberAdd = <
  TError =
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelMemberAdd>>,
      TError,
      Key,
      ChannelMemberAdd,
      Awaited<ReturnType<typeof channelMemberAdd>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ?? getChannelMemberAddMutationKey(channelID);
  const swrFn = getChannelMemberAddMutationFetcher(channelID);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Update a member's role in a channel. Requires owner or admin role.
 */
export const channelMemberUpdateRole = (
  channelID: string,
  accountID: string,
  channelMemberRoleUpdate: ChannelMemberRoleUpdate,
) => {
  return fetcher<ChannelMemberOKResponse>({
    url: `/channels/${channelID}/members/${accountID}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: channelMemberRoleUpdate,
  });
};

export const getChannelMemberUpdateRoleMutationFetcher = (
  channelID: string,
  accountID: string,
) => {
  return (
    _: Key,
    { arg }: { arg: ChannelMemberRoleUpdate },
  ): Promise<ChannelMemberOKResponse> => {
    return channelMemberUpdateRole(channelID, accountID, arg);
  };
};
export const getChannelMemberUpdateRoleMutationKey = (
  channelID: string,
  accountID: string,
) => [`/channels/${channelID}/members/${accountID}`] as const;

export type ChannelMemberUpdateRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelMemberUpdateRole>>
>;
export type ChannelMemberUpdateRoleMutationError =
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelMemberUpdateRole = <
  TError =
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  accountID: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelMemberUpdateRole>>,
      TError,
      Key,
      ChannelMemberRoleUpdate,
      Awaited<ReturnType<typeof channelMemberUpdateRole>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ??
    getChannelMemberUpdateRoleMutationKey(channelID, accountID);
  const swrFn = getChannelMemberUpdateRoleMutationFetcher(channelID, accountID);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Remove a member from a channel. Requires owner or admin role.
 */
export const channelMemberRemove = (channelID: string, accountID: string) => {
  return fetcher<void>({
    url: `/channels/${channelID}/members/${accountID}`,
    method: "DELETE",
  });
};

export const getChannelMemberRemoveMutationFetcher = (
  channelID: string,
  accountID: string,
) => {
  return (_: Key, __: { arg: Arguments }): Promise<void> => {
    return channelMemberRemove(channelID, accountID);
  };
};
export const getChannelMemberRemoveMutationKey = (
  channelID: string,
  accountID: string,
) => [`/channels/${channelID}/members/${accountID}`] as const;

export type ChannelMemberRemoveMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelMemberRemove>>
>;
export type ChannelMemberRemoveMutationError =
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelMemberRemove = <
  TError =
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  accountID: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelMemberRemove>>,
      TError,
      Key,
      Arguments,
      Awaited<ReturnType<typeof channelMemberRemove>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ??
    getChannelMemberRemoveMutationKey(channelID, accountID);
  const swrFn = getChannelMemberRemoveMutationFetcher(channelID, accountID);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Join a public channel as a member. Only works for public channels.
 */
export const channelJoin = (channelID: string) => {
  return fetcher<ChannelMemberOKResponse>({
    url: `/channels/${channelID}/join`,
    method: "POST",
  });
};

export const getChannelJoinMutationFetcher = (channelID: string) => {
  return (_: Key, __: { arg: Arguments }): Promise<ChannelMemberOKResponse> => {
    return channelJoin(channelID);
  };
};
export const getChannelJoinMutationKey = (channelID: string) =>
  [`/channels/${channelID}/join`] as const;

export type ChannelJoinMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelJoin>>
>;
export type ChannelJoinMutationError =
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelJoin = <
  TError =
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelJoin>>,
      TError,
      Key,
      Arguments,
      Awaited<ReturnType<typeof channelJoin>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getChannelJoinMutationKey(channelID);
  const swrFn = getChannelJoinMutationFetcher(channelID);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Leave a channel. Cannot leave if you are the only owner.
 */
export const channelLeave = (channelID: string) => {
  return fetcher<void>({ url: `/channels/${channelID}/leave`, method: "POST" });
};

export const getChannelLeaveMutationFetcher = (channelID: string) => {
  return (_: Key, __: { arg: Arguments }): Promise<void> => {
    return channelLeave(channelID);
  };
};
export const getChannelLeaveMutationKey = (channelID: string) =>
  [`/channels/${channelID}/leave`] as const;

export type ChannelLeaveMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelLeave>>
>;
export type ChannelLeaveMutationError =
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelLeave = <
  TError =
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelLeave>>,
      TError,
      Key,
      Arguments,
      Awaited<ReturnType<typeof channelLeave>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getChannelLeaveMutationKey(channelID);
  const swrFn = getChannelLeaveMutationFetcher(channelID);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get all categories in a channel.
 */
export const channelCategoryList = (channelID: string) => {
  return fetcher<CategoryListOKResponse>({
    url: `/channels/${channelID}/categories`,
    method: "GET",
  });
};

export const getChannelCategoryListKey = (channelID: string) =>
  [`/channels/${channelID}/categories`] as const;

export type ChannelCategoryListQueryResult = NonNullable<
  Awaited<ReturnType<typeof channelCategoryList>>
>;
export type ChannelCategoryListQueryError =
  | UnauthorisedResponse
  | ForbiddenResponse
  | InternalServerErrorResponse;

export const useChannelCategoryList = <
  TError =
    | UnauthorisedResponse
    | ForbiddenResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof channelCategoryList>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!channelID;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getChannelCategoryListKey(channelID) : null));
  const swrFn = () => channelCategoryList(channelID);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Create a category in a channel.
 */
export const channelCategoryCreate = (
  channelID: string,
  categoryCreateBody: CategoryCreateBody,
) => {
  return fetcher<CategoryCreateOKResponse>({
    url: `/channels/${channelID}/categories`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: categoryCreateBody,
  });
};

export const getChannelCategoryCreateMutationFetcher = (channelID: string) => {
  return (
    _: Key,
    { arg }: { arg: CategoryCreateBody },
  ): Promise<CategoryCreateOKResponse> => {
    return channelCategoryCreate(channelID, arg);
  };
};
export const getChannelCategoryCreateMutationKey = (channelID: string) =>
  [`/channels/${channelID}/categories`] as const;

export type ChannelCategoryCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelCategoryCreate>>
>;
export type ChannelCategoryCreateMutationError =
  | BadRequestResponse
  | UnauthorisedResponse
  | ForbiddenResponse
  | InternalServerErrorResponse;

export const useChannelCategoryCreate = <
  TError =
    | BadRequestResponse
    | UnauthorisedResponse
    | ForbiddenResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelCategoryCreate>>,
      TError,
      Key,
      CategoryCreateBody,
      Awaited<ReturnType<typeof channelCategoryCreate>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ?? getChannelCategoryCreateMutationKey(channelID);
  const swrFn = getChannelCategoryCreateMutationFetcher(channelID);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get a specific category in a channel.
 */
export const channelCategoryGet = (channelID: string, categorySlug: string) => {
  return fetcher<CategoryGetOKResponse>({
    url: `/channels/${channelID}/categories/${categorySlug}`,
    method: "GET",
  });
};

export const getChannelCategoryGetKey = (
  channelID: string,
  categorySlug: string,
) => [`/channels/${channelID}/categories/${categorySlug}`] as const;

export type ChannelCategoryGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof channelCategoryGet>>
>;
export type ChannelCategoryGetQueryError =
  | NotModifiedResponse
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelCategoryGet = <
  TError =
    | NotModifiedResponse
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  categorySlug: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof channelCategoryGet>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled =
    swrOptions?.enabled !== false && !!(channelID && categorySlug);
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled ? getChannelCategoryGetKey(channelID, categorySlug) : null);
  const swrFn = () => channelCategoryGet(channelID, categorySlug);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Update a category in a channel.
 */
export const channelCategoryUpdate = (
  channelID: string,
  categorySlug: string,
  categoryUpdateBody: CategoryUpdateBody,
) => {
  return fetcher<CategoryUpdateOKResponse>({
    url: `/channels/${channelID}/categories/${categorySlug}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: categoryUpdateBody,
  });
};

export const getChannelCategoryUpdateMutationFetcher = (
  channelID: string,
  categorySlug: string,
) => {
  return (
    _: Key,
    { arg }: { arg: CategoryUpdateBody },
  ): Promise<CategoryUpdateOKResponse> => {
    return channelCategoryUpdate(channelID, categorySlug, arg);
  };
};
export const getChannelCategoryUpdateMutationKey = (
  channelID: string,
  categorySlug: string,
) => [`/channels/${channelID}/categories/${categorySlug}`] as const;

export type ChannelCategoryUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelCategoryUpdate>>
>;
export type ChannelCategoryUpdateMutationError =
  | BadRequestResponse
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelCategoryUpdate = <
  TError =
    | BadRequestResponse
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  categorySlug: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelCategoryUpdate>>,
      TError,
      Key,
      CategoryUpdateBody,
      Awaited<ReturnType<typeof channelCategoryUpdate>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ??
    getChannelCategoryUpdateMutationKey(channelID, categorySlug);
  const swrFn = getChannelCategoryUpdateMutationFetcher(
    channelID,
    categorySlug,
  );

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Delete a category. Posts will be moved to target category.
 */
export const channelCategoryDelete = (
  channelID: string,
  categorySlug: string,
  categoryDeleteBody: CategoryDeleteBody,
) => {
  return fetcher<CategoryDeleteOKResponse>({
    url: `/channels/${channelID}/categories/${categorySlug}`,
    method: "DELETE",
    headers: { "Content-Type": "application/json" },
    data: categoryDeleteBody,
  });
};

export const getChannelCategoryDeleteMutationFetcher = (
  channelID: string,
  categorySlug: string,
) => {
  return (
    _: Key,
    { arg }: { arg: CategoryDeleteBody },
  ): Promise<CategoryDeleteOKResponse> => {
    return channelCategoryDelete(channelID, categorySlug, arg);
  };
};
export const getChannelCategoryDeleteMutationKey = (
  channelID: string,
  categorySlug: string,
) => [`/channels/${channelID}/categories/${categorySlug}`] as const;

export type ChannelCategoryDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelCategoryDelete>>
>;
export type ChannelCategoryDeleteMutationError =
  | BadRequestResponse
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelCategoryDelete = <
  TError =
    | BadRequestResponse
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  categorySlug: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelCategoryDelete>>,
      TError,
      Key,
      CategoryDeleteBody,
      Awaited<ReturnType<typeof channelCategoryDelete>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ??
    getChannelCategoryDeleteMutationKey(channelID, categorySlug);
  const swrFn = getChannelCategoryDeleteMutationFetcher(
    channelID,
    categorySlug,
  );

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Update category position in the tree for drag-and-drop.
 */
export const channelCategoryUpdatePosition = (
  channelID: string,
  categorySlug: string,
  categoryUpdatePositionBody: CategoryUpdatePositionBody,
) => {
  return fetcher<CategoryListOKResponse>({
    url: `/channels/${channelID}/categories/${categorySlug}/position`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: categoryUpdatePositionBody,
  });
};

export const getChannelCategoryUpdatePositionMutationFetcher = (
  channelID: string,
  categorySlug: string,
) => {
  return (
    _: Key,
    { arg }: { arg: CategoryUpdatePositionBody },
  ): Promise<CategoryListOKResponse> => {
    return channelCategoryUpdatePosition(channelID, categorySlug, arg);
  };
};
export const getChannelCategoryUpdatePositionMutationKey = (
  channelID: string,
  categorySlug: string,
) => [`/channels/${channelID}/categories/${categorySlug}/position`] as const;

export type ChannelCategoryUpdatePositionMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelCategoryUpdatePosition>>
>;
export type ChannelCategoryUpdatePositionMutationError =
  | BadRequestResponse
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelCategoryUpdatePosition = <
  TError =
    | BadRequestResponse
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  categorySlug: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelCategoryUpdatePosition>>,
      TError,
      Key,
      CategoryUpdatePositionBody,
      Awaited<ReturnType<typeof channelCategoryUpdatePosition>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ??
    getChannelCategoryUpdatePositionMutationKey(channelID, categorySlug);
  const swrFn = getChannelCategoryUpdatePositionMutationFetcher(
    channelID,
    categorySlug,
  );

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Create a new thread within a channel category.
 */
export const channelThreadCreate = (
  channelID: string,
  threadCreateBody: ThreadCreateBody,
) => {
  return fetcher<ThreadCreateOKResponse>({
    url: `/channels/${channelID}/threads`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: threadCreateBody,
  });
};

export const getChannelThreadCreateMutationFetcher = (channelID: string) => {
  return (
    _: Key,
    { arg }: { arg: ThreadCreateBody },
  ): Promise<ThreadCreateOKResponse> => {
    return channelThreadCreate(channelID, arg);
  };
};
export const getChannelThreadCreateMutationKey = (channelID: string) =>
  [`/channels/${channelID}/threads`] as const;

export type ChannelThreadCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelThreadCreate>>
>;
export type ChannelThreadCreateMutationError =
  | BadRequestResponse
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelThreadCreate = <
  TError =
    | BadRequestResponse
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelThreadCreate>>,
      TError,
      Key,
      ThreadCreateBody,
      Awaited<ReturnType<typeof channelThreadCreate>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ?? getChannelThreadCreateMutationKey(channelID);
  const swrFn = getChannelThreadCreateMutationFetcher(channelID);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get a list of threads in a channel.
 */
export const channelThreadList = (
  channelID: string,
  params?: ChannelThreadListParams,
) => {
  return fetcher<ThreadListOKResponse>({
    url: `/channels/${channelID}/threads`,
    method: "GET",
    params,
  });
};

export const getChannelThreadListKey = (
  channelID: string,
  params?: ChannelThreadListParams,
) => [`/channels/${channelID}/threads`, ...(params ? [params] : [])] as const;

export type ChannelThreadListQueryResult = NonNullable<
  Awaited<ReturnType<typeof channelThreadList>>
>;
export type ChannelThreadListQueryError =
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelThreadList = <
  TError =
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  params?: ChannelThreadListParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof channelThreadList>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!channelID;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getChannelThreadListKey(channelID, params) : null));
  const swrFn = () => channelThreadList(channelID, params);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get information about a thread in a channel including its posts.
 * @summary Get a thread from a channel.
 */
export const channelThreadGet = (
  channelID: string,
  threadMark: string,
  params?: ChannelThreadGetParams,
) => {
  return fetcher<ThreadGetResponse>({
    url: `/channels/${channelID}/threads/${threadMark}`,
    method: "GET",
    params,
  });
};

export const getChannelThreadGetKey = (
  channelID: string,
  threadMark: string,
  params?: ChannelThreadGetParams,
) =>
  [
    `/channels/${channelID}/threads/${threadMark}`,
    ...(params ? [params] : []),
  ] as const;

export type ChannelThreadGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof channelThreadGet>>
>;
export type ChannelThreadGetQueryError =
  | NotModifiedResponse
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

/**
 * @summary Get a thread from a channel.
 */
export const useChannelThreadGet = <
  TError =
    | NotModifiedResponse
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  threadMark: string,
  params?: ChannelThreadGetParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof channelThreadGet>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled =
    swrOptions?.enabled !== false && !!(channelID && threadMark);
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled ? getChannelThreadGetKey(channelID, threadMark, params) : null);
  const swrFn = () => channelThreadGet(channelID, threadMark, params);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Update a thread in a channel.
 */
export const channelThreadUpdate = (
  channelID: string,
  threadMark: string,
  threadUpdateBody: ThreadUpdateBody,
) => {
  return fetcher<ThreadUpdateOKResponse>({
    url: `/channels/${channelID}/threads/${threadMark}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: threadUpdateBody,
  });
};

export const getChannelThreadUpdateMutationFetcher = (
  channelID: string,
  threadMark: string,
) => {
  return (
    _: Key,
    { arg }: { arg: ThreadUpdateBody },
  ): Promise<ThreadUpdateOKResponse> => {
    return channelThreadUpdate(channelID, threadMark, arg);
  };
};
export const getChannelThreadUpdateMutationKey = (
  channelID: string,
  threadMark: string,
) => [`/channels/${channelID}/threads/${threadMark}`] as const;

export type ChannelThreadUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelThreadUpdate>>
>;
export type ChannelThreadUpdateMutationError =
  | BadRequestResponse
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelThreadUpdate = <
  TError =
    | BadRequestResponse
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  threadMark: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelThreadUpdate>>,
      TError,
      Key,
      ThreadUpdateBody,
      Awaited<ReturnType<typeof channelThreadUpdate>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ??
    getChannelThreadUpdateMutationKey(channelID, threadMark);
  const swrFn = getChannelThreadUpdateMutationFetcher(channelID, threadMark);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Delete a thread in a channel.
 */
export const channelThreadDelete = (channelID: string, threadMark: string) => {
  return fetcher<void>({
    url: `/channels/${channelID}/threads/${threadMark}`,
    method: "DELETE",
  });
};

export const getChannelThreadDeleteMutationFetcher = (
  channelID: string,
  threadMark: string,
) => {
  return (_: Key, __: { arg: Arguments }): Promise<void> => {
    return channelThreadDelete(channelID, threadMark);
  };
};
export const getChannelThreadDeleteMutationKey = (
  channelID: string,
  threadMark: string,
) => [`/channels/${channelID}/threads/${threadMark}`] as const;

export type ChannelThreadDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelThreadDelete>>
>;
export type ChannelThreadDeleteMutationError =
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelThreadDelete = <
  TError =
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  threadMark: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelThreadDelete>>,
      TError,
      Key,
      Arguments,
      Awaited<ReturnType<typeof channelThreadDelete>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ??
    getChannelThreadDeleteMutationKey(channelID, threadMark);
  const swrFn = getChannelThreadDeleteMutationFetcher(channelID, threadMark);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Create a new reply within a thread in a channel.
 */
export const channelReplyCreate = (
  channelID: string,
  threadMark: string,
  replyCreateBody: ReplyCreateBody,
) => {
  return fetcher<ReplyCreateOKResponse>({
    url: `/channels/${channelID}/threads/${threadMark}/replies`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: replyCreateBody,
  });
};

export const getChannelReplyCreateMutationFetcher = (
  channelID: string,
  threadMark: string,
) => {
  return (
    _: Key,
    { arg }: { arg: ReplyCreateBody },
  ): Promise<ReplyCreateOKResponse> => {
    return channelReplyCreate(channelID, threadMark, arg);
  };
};
export const getChannelReplyCreateMutationKey = (
  channelID: string,
  threadMark: string,
) => [`/channels/${channelID}/threads/${threadMark}/replies`] as const;

export type ChannelReplyCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelReplyCreate>>
>;
export type ChannelReplyCreateMutationError =
  | BadRequestResponse
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelReplyCreate = <
  TError =
    | BadRequestResponse
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  threadMark: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelReplyCreate>>,
      TError,
      Key,
      ReplyCreateBody,
      Awaited<ReturnType<typeof channelReplyCreate>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ??
    getChannelReplyCreateMutationKey(channelID, threadMark);
  const swrFn = getChannelReplyCreateMutationFetcher(channelID, threadMark);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Create a collection within a channel for curating posts.
 */
export const channelCollectionCreate = (
  channelID: string,
  collectionCreateBody: CollectionCreateBody,
) => {
  return fetcher<CollectionCreateOKResponse>({
    url: `/channels/${channelID}/collections`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: collectionCreateBody,
  });
};

export const getChannelCollectionCreateMutationFetcher = (
  channelID: string,
) => {
  return (
    _: Key,
    { arg }: { arg: CollectionCreateBody },
  ): Promise<CollectionCreateOKResponse> => {
    return channelCollectionCreate(channelID, arg);
  };
};
export const getChannelCollectionCreateMutationKey = (channelID: string) =>
  [`/channels/${channelID}/collections`] as const;

export type ChannelCollectionCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelCollectionCreate>>
>;
export type ChannelCollectionCreateMutationError =
  | BadRequestResponse
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelCollectionCreate = <
  TError =
    | BadRequestResponse
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelCollectionCreate>>,
      TError,
      Key,
      CollectionCreateBody,
      Awaited<ReturnType<typeof channelCollectionCreate>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ?? getChannelCollectionCreateMutationKey(channelID);
  const swrFn = getChannelCollectionCreateMutationFetcher(channelID);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get a list of collections within a channel.
 */
export const channelCollectionList = (
  channelID: string,
  params?: ChannelCollectionListParams,
) => {
  return fetcher<CollectionListOKResponse>({
    url: `/channels/${channelID}/collections`,
    method: "GET",
    params,
  });
};

export const getChannelCollectionListKey = (
  channelID: string,
  params?: ChannelCollectionListParams,
) =>
  [`/channels/${channelID}/collections`, ...(params ? [params] : [])] as const;

export type ChannelCollectionListQueryResult = NonNullable<
  Awaited<ReturnType<typeof channelCollectionList>>
>;
export type ChannelCollectionListQueryError =
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelCollectionList = <
  TError = NotFoundResponse | InternalServerErrorResponse,
>(
  channelID: string,
  params?: ChannelCollectionListParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof channelCollectionList>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!channelID;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getChannelCollectionListKey(channelID, params) : null));
  const swrFn = () => channelCollectionList(channelID, params);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get a collection by its ID within a channel.
 */
export const channelCollectionGet = (
  channelID: string,
  collectionMark: string,
) => {
  return fetcher<CollectionGetOKResponse>({
    url: `/channels/${channelID}/collections/${collectionMark}`,
    method: "GET",
  });
};

export const getChannelCollectionGetKey = (
  channelID: string,
  collectionMark: string,
) => [`/channels/${channelID}/collections/${collectionMark}`] as const;

export type ChannelCollectionGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof channelCollectionGet>>
>;
export type ChannelCollectionGetQueryError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelCollectionGet = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  collectionMark: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof channelCollectionGet>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled =
    swrOptions?.enabled !== false && !!(channelID && collectionMark);
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled ? getChannelCollectionGetKey(channelID, collectionMark) : null);
  const swrFn = () => channelCollectionGet(channelID, collectionMark);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Update a collection within a channel.
 */
export const channelCollectionUpdate = (
  channelID: string,
  collectionMark: string,
  collectionUpdateBody: CollectionUpdateBody,
) => {
  return fetcher<CollectionUpdateOKResponse>({
    url: `/channels/${channelID}/collections/${collectionMark}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: collectionUpdateBody,
  });
};

export const getChannelCollectionUpdateMutationFetcher = (
  channelID: string,
  collectionMark: string,
) => {
  return (
    _: Key,
    { arg }: { arg: CollectionUpdateBody },
  ): Promise<CollectionUpdateOKResponse> => {
    return channelCollectionUpdate(channelID, collectionMark, arg);
  };
};
export const getChannelCollectionUpdateMutationKey = (
  channelID: string,
  collectionMark: string,
) => [`/channels/${channelID}/collections/${collectionMark}`] as const;

export type ChannelCollectionUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelCollectionUpdate>>
>;
export type ChannelCollectionUpdateMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelCollectionUpdate = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  collectionMark: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelCollectionUpdate>>,
      TError,
      Key,
      CollectionUpdateBody,
      Awaited<ReturnType<typeof channelCollectionUpdate>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ??
    getChannelCollectionUpdateMutationKey(channelID, collectionMark);
  const swrFn = getChannelCollectionUpdateMutationFetcher(
    channelID,
    collectionMark,
  );

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Delete a collection within a channel.
 */
export const channelCollectionDelete = (
  channelID: string,
  collectionMark: string,
) => {
  return fetcher<void>({
    url: `/channels/${channelID}/collections/${collectionMark}`,
    method: "DELETE",
  });
};

export const getChannelCollectionDeleteMutationFetcher = (
  channelID: string,
  collectionMark: string,
) => {
  return (_: Key, __: { arg: Arguments }): Promise<void> => {
    return channelCollectionDelete(channelID, collectionMark);
  };
};
export const getChannelCollectionDeleteMutationKey = (
  channelID: string,
  collectionMark: string,
) => [`/channels/${channelID}/collections/${collectionMark}`] as const;

export type ChannelCollectionDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelCollectionDelete>>
>;
export type ChannelCollectionDeleteMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelCollectionDelete = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  collectionMark: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelCollectionDelete>>,
      TError,
      Key,
      Arguments,
      Awaited<ReturnType<typeof channelCollectionDelete>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ??
    getChannelCollectionDeleteMutationKey(channelID, collectionMark);
  const swrFn = getChannelCollectionDeleteMutationFetcher(
    channelID,
    collectionMark,
  );

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};

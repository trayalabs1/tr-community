/**
 * Generated by orval v7.2.0 ðŸº
 * Do not edit manually.
 * storyden
 * Storyden social API for building community driven platforms.
The Storyden API does not adhere to semantic versioning but instead applies a rolling strategy with deprecations and minimal breaking changes. This has been done mainly for a simpler development process and it may be changed to a more fixed versioning strategy in the future. Ultimately, the primary way Storyden tracks versions is dates, there are no set release tags currently.

 * OpenAPI spec version: v1.25.13-canary
 */
import useSwr from "swr";
import type { Arguments, Key, SWRConfiguration } from "swr";
import useSWRMutation from "swr/mutation";
import type { SWRMutationConfiguration } from "swr/mutation";

import { fetcher } from "../client";
import type {
  BadRequestResponse,
  ChannelThreadGetParams,
  ChannelThreadListParams,
  ForbiddenResponse,
  InternalServerErrorResponse,
  NotFoundResponse,
  NotModifiedResponse,
  ReplyCreateBody,
  ReplyCreateOKResponse,
  ThreadCreateBody,
  ThreadCreateOKResponse,
  ThreadGetParams,
  ThreadGetResponse,
  ThreadListOKResponse,
  ThreadListParams,
  ThreadUpdateBody,
  ThreadUpdateOKResponse,
  UnauthorisedResponse,
} from "../openapi-schema";

/**
 * Create a new thread within a channel category.
 */
export const channelThreadCreate = (
  channelID: string,
  threadCreateBody: ThreadCreateBody,
) => {
  return fetcher<ThreadCreateOKResponse>({
    url: `/channels/${channelID}/threads`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: threadCreateBody,
  });
};

export const getChannelThreadCreateMutationFetcher = (channelID: string) => {
  return (
    _: Key,
    { arg }: { arg: ThreadCreateBody },
  ): Promise<ThreadCreateOKResponse> => {
    return channelThreadCreate(channelID, arg);
  };
};
export const getChannelThreadCreateMutationKey = (channelID: string) =>
  [`/channels/${channelID}/threads`] as const;

export type ChannelThreadCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelThreadCreate>>
>;
export type ChannelThreadCreateMutationError =
  | BadRequestResponse
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelThreadCreate = <
  TError =
    | BadRequestResponse
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelThreadCreate>>,
      TError,
      Key,
      ThreadCreateBody,
      Awaited<ReturnType<typeof channelThreadCreate>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ?? getChannelThreadCreateMutationKey(channelID);
  const swrFn = getChannelThreadCreateMutationFetcher(channelID);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get a list of threads in a channel.
 */
export const channelThreadList = (
  channelID: string,
  params?: ChannelThreadListParams,
) => {
  return fetcher<ThreadListOKResponse>({
    url: `/channels/${channelID}/threads`,
    method: "GET",
    params,
  });
};

export const getChannelThreadListKey = (
  channelID: string,
  params?: ChannelThreadListParams,
) => [`/channels/${channelID}/threads`, ...(params ? [params] : [])] as const;

export type ChannelThreadListQueryResult = NonNullable<
  Awaited<ReturnType<typeof channelThreadList>>
>;
export type ChannelThreadListQueryError =
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelThreadList = <
  TError =
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  params?: ChannelThreadListParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof channelThreadList>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!channelID;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getChannelThreadListKey(channelID, params) : null));
  const swrFn = () => channelThreadList(channelID, params);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get information about a thread in a channel including its posts.
 * @summary Get a thread from a channel.
 */
export const channelThreadGet = (
  channelID: string,
  threadMark: string,
  params?: ChannelThreadGetParams,
) => {
  return fetcher<ThreadGetResponse>({
    url: `/channels/${channelID}/threads/${threadMark}`,
    method: "GET",
    params,
  });
};

export const getChannelThreadGetKey = (
  channelID: string,
  threadMark: string,
  params?: ChannelThreadGetParams,
) =>
  [
    `/channels/${channelID}/threads/${threadMark}`,
    ...(params ? [params] : []),
  ] as const;

export type ChannelThreadGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof channelThreadGet>>
>;
export type ChannelThreadGetQueryError =
  | NotModifiedResponse
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

/**
 * @summary Get a thread from a channel.
 */
export const useChannelThreadGet = <
  TError =
    | NotModifiedResponse
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  threadMark: string,
  params?: ChannelThreadGetParams,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof channelThreadGet>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled =
    swrOptions?.enabled !== false && !!(channelID && threadMark);
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled ? getChannelThreadGetKey(channelID, threadMark, params) : null);
  const swrFn = () => channelThreadGet(channelID, threadMark, params);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Update a thread in a channel.
 */
export const channelThreadUpdate = (
  channelID: string,
  threadMark: string,
  threadUpdateBody: ThreadUpdateBody,
) => {
  return fetcher<ThreadUpdateOKResponse>({
    url: `/channels/${channelID}/threads/${threadMark}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: threadUpdateBody,
  });
};

export const getChannelThreadUpdateMutationFetcher = (
  channelID: string,
  threadMark: string,
) => {
  return (
    _: Key,
    { arg }: { arg: ThreadUpdateBody },
  ): Promise<ThreadUpdateOKResponse> => {
    return channelThreadUpdate(channelID, threadMark, arg);
  };
};
export const getChannelThreadUpdateMutationKey = (
  channelID: string,
  threadMark: string,
) => [`/channels/${channelID}/threads/${threadMark}`] as const;

export type ChannelThreadUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelThreadUpdate>>
>;
export type ChannelThreadUpdateMutationError =
  | BadRequestResponse
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelThreadUpdate = <
  TError =
    | BadRequestResponse
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  threadMark: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelThreadUpdate>>,
      TError,
      Key,
      ThreadUpdateBody,
      Awaited<ReturnType<typeof channelThreadUpdate>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ??
    getChannelThreadUpdateMutationKey(channelID, threadMark);
  const swrFn = getChannelThreadUpdateMutationFetcher(channelID, threadMark);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Delete a thread in a channel.
 */
export const channelThreadDelete = (channelID: string, threadMark: string) => {
  return fetcher<void>({
    url: `/channels/${channelID}/threads/${threadMark}`,
    method: "DELETE",
  });
};

export const getChannelThreadDeleteMutationFetcher = (
  channelID: string,
  threadMark: string,
) => {
  return (_: Key, __: { arg: Arguments }): Promise<void> => {
    return channelThreadDelete(channelID, threadMark);
  };
};
export const getChannelThreadDeleteMutationKey = (
  channelID: string,
  threadMark: string,
) => [`/channels/${channelID}/threads/${threadMark}`] as const;

export type ChannelThreadDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelThreadDelete>>
>;
export type ChannelThreadDeleteMutationError =
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelThreadDelete = <
  TError =
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  threadMark: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelThreadDelete>>,
      TError,
      Key,
      Arguments,
      Awaited<ReturnType<typeof channelThreadDelete>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ??
    getChannelThreadDeleteMutationKey(channelID, threadMark);
  const swrFn = getChannelThreadDeleteMutationFetcher(channelID, threadMark);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Create a new reply within a thread in a channel.
 */
export const channelReplyCreate = (
  channelID: string,
  threadMark: string,
  replyCreateBody: ReplyCreateBody,
) => {
  return fetcher<ReplyCreateOKResponse>({
    url: `/channels/${channelID}/threads/${threadMark}/replies`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: replyCreateBody,
  });
};

export const getChannelReplyCreateMutationFetcher = (
  channelID: string,
  threadMark: string,
) => {
  return (
    _: Key,
    { arg }: { arg: ReplyCreateBody },
  ): Promise<ReplyCreateOKResponse> => {
    return channelReplyCreate(channelID, threadMark, arg);
  };
};
export const getChannelReplyCreateMutationKey = (
  channelID: string,
  threadMark: string,
) => [`/channels/${channelID}/threads/${threadMark}/replies`] as const;

export type ChannelReplyCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof channelReplyCreate>>
>;
export type ChannelReplyCreateMutationError =
  | BadRequestResponse
  | UnauthorisedResponse
  | ForbiddenResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useChannelReplyCreate = <
  TError =
    | BadRequestResponse
    | UnauthorisedResponse
    | ForbiddenResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  channelID: string,
  threadMark: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof channelReplyCreate>>,
      TError,
      Key,
      ReplyCreateBody,
      Awaited<ReturnType<typeof channelReplyCreate>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey =
    swrOptions?.swrKey ??
    getChannelReplyCreateMutationKey(channelID, threadMark);
  const swrFn = getChannelReplyCreateMutationFetcher(channelID, threadMark);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Create a new thread within the specified category.
 */
export const threadCreate = (threadCreateBody: ThreadCreateBody) => {
  return fetcher<ThreadCreateOKResponse>({
    url: `/threads`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: threadCreateBody,
  });
};

export const getThreadCreateMutationFetcher = () => {
  return (
    _: Key,
    { arg }: { arg: ThreadCreateBody },
  ): Promise<ThreadCreateOKResponse> => {
    return threadCreate(arg);
  };
};
export const getThreadCreateMutationKey = () => [`/threads`] as const;

export type ThreadCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof threadCreate>>
>;
export type ThreadCreateMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useThreadCreate = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(options?: {
  swr?: SWRMutationConfiguration<
    Awaited<ReturnType<typeof threadCreate>>,
    TError,
    Key,
    ThreadCreateBody,
    Awaited<ReturnType<typeof threadCreate>>
  > & { swrKey?: string };
}) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getThreadCreateMutationKey();
  const swrFn = getThreadCreateMutationFetcher();

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get a list of all threads.
 */
export const threadList = (params?: ThreadListParams) => {
  return fetcher<ThreadListOKResponse>({
    url: `/threads`,
    method: "GET",
    params,
  });
};

export const getThreadListKey = (params?: ThreadListParams) =>
  [`/threads`, ...(params ? [params] : [])] as const;

export type ThreadListQueryResult = NonNullable<
  Awaited<ReturnType<typeof threadList>>
>;
export type ThreadListQueryError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useThreadList = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  params?: ThreadListParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof threadList>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getThreadListKey(params) : null));
  const swrFn = () => threadList(params);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Get information about a thread such as its title, author, when it was
created as well as a list of the posts within the thread.

 * @summary Get information about a thread and the posts within the thread.
 */
export const threadGet = (threadMark: string, params?: ThreadGetParams) => {
  return fetcher<ThreadGetResponse>({
    url: `/threads/${threadMark}`,
    method: "GET",
    params,
  });
};

export const getThreadGetKey = (threadMark: string, params?: ThreadGetParams) =>
  [`/threads/${threadMark}`, ...(params ? [params] : [])] as const;

export type ThreadGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof threadGet>>
>;
export type ThreadGetQueryError =
  | NotModifiedResponse
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

/**
 * @summary Get information about a thread and the posts within the thread.
 */
export const useThreadGet = <
  TError =
    | NotModifiedResponse
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  threadMark: string,
  params?: ThreadGetParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof threadGet>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!threadMark;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getThreadGetKey(threadMark, params) : null));
  const swrFn = () => threadGet(threadMark, params);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
/**
 * Publish changes to a thread.
 */
export const threadUpdate = (
  threadMark: string,
  threadUpdateBody: ThreadUpdateBody,
) => {
  return fetcher<ThreadUpdateOKResponse>({
    url: `/threads/${threadMark}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: threadUpdateBody,
  });
};

export const getThreadUpdateMutationFetcher = (threadMark: string) => {
  return (
    _: Key,
    { arg }: { arg: ThreadUpdateBody },
  ): Promise<ThreadUpdateOKResponse> => {
    return threadUpdate(threadMark, arg);
  };
};
export const getThreadUpdateMutationKey = (threadMark: string) =>
  [`/threads/${threadMark}`] as const;

export type ThreadUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof threadUpdate>>
>;
export type ThreadUpdateMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useThreadUpdate = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  threadMark: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof threadUpdate>>,
      TError,
      Key,
      ThreadUpdateBody,
      Awaited<ReturnType<typeof threadUpdate>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getThreadUpdateMutationKey(threadMark);
  const swrFn = getThreadUpdateMutationFetcher(threadMark);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
/**
 * Archive a thread using soft-delete.
 */
export const threadDelete = (threadMark: string) => {
  return fetcher<void>({ url: `/threads/${threadMark}`, method: "DELETE" });
};

export const getThreadDeleteMutationFetcher = (threadMark: string) => {
  return (_: Key, __: { arg: Arguments }): Promise<void> => {
    return threadDelete(threadMark);
  };
};
export const getThreadDeleteMutationKey = (threadMark: string) =>
  [`/threads/${threadMark}`] as const;

export type ThreadDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof threadDelete>>
>;
export type ThreadDeleteMutationError =
  | UnauthorisedResponse
  | NotFoundResponse
  | InternalServerErrorResponse;

export const useThreadDelete = <
  TError =
    | UnauthorisedResponse
    | NotFoundResponse
    | InternalServerErrorResponse,
>(
  threadMark: string,
  options?: {
    swr?: SWRMutationConfiguration<
      Awaited<ReturnType<typeof threadDelete>>,
      TError,
      Key,
      Arguments,
      Awaited<ReturnType<typeof threadDelete>>
    > & { swrKey?: string };
  },
) => {
  const { swr: swrOptions } = options ?? {};

  const swrKey = swrOptions?.swrKey ?? getThreadDeleteMutationKey(threadMark);
  const swrFn = getThreadDeleteMutationFetcher(threadMark);

  const query = useSWRMutation(swrKey, swrFn, swrOptions);

  return {
    swrKey,
    ...query,
  };
};
